{% load static %}
<div id="Col2" class="col-lg-6 col-md-8">

    {% comment %} position bar {% endcomment %}
    <div class="container text-center text-bg-warning rounded mt-2">
        <ul class="bg-warning py-2">
            <li class="list-unstyled d-inline">
                <a href="{% url 'programming' %}" class="Link text-decoration-none text-dark">
                    programming
                </a>
            </li>
            <li class="list-unstyled text-dark d-inline">/</li>
            <li class="list-unstyled d-inline">
                <a href="{% url 'programming_py' %}" class="Link text-decoration-none text-dark">
                    python
                </a>
            </li>
            <li class="list-unstyled text-dark d-inline">/</li>
            <li class="list-unstyled d-inline">
                <a href="{% url 'programming_py_net_inter_com_signal' %}" class="Link text-decoration-none text-dark">
                    signal
                </a>
            </li>
        </ul>
    </div>

    <!-- <div class="container-fluid mt-2">
        <div class="container-fluid d-flex justify-content-center">
            <img class="h-100 w-100" src="{% static 'images/concurrency/PythonThreading' %}" alt="img not found">
        </div>
        <div class="container-fluid text-center">
            <small>Fig 1. Threading</small>
        </div>
    </div> -->

    <div class="container mt-4">
        <div class="container">
            <h3>signal: Asynchronous System Events</h3>
        </div>
        
        <div class="container">
            <p class="m-3 text-secondary">
               Signals are on operating system feature that provide a means of notifying a program of en event, and having it handled asynchronously. They can be generated by the system itself, or sent from one process to another. Since signals interrupt the regular flow of the program, it is possible that some operations (especially I/O) may produce errors if a signal is recevied while they are ongoing.
            </p>
        </div>

        <div class="container">
            <p class="m-3 text-info">
                Signals are identified by integers and are defined in the operating system C headers. Python exposes the signals appropriate for the platform as symbols in the <i>signal</i> module.
            </p>
        </div>


        <div id="SignalRecevingSignals" class="container">
            <h3>Receiving Signals</h3>
        </div>

        <div class="container">
            <p class="m-3 text-secondary">
                With other forms of event-based programming, signals are recevied by establishing a callback function, called a <i>signal handler</i>, that is invoked whe nthe signal occurs. The arguments to the signal handler are the signal number and the stack frame from the point in the program that was interrupted by the signal.
            </p>
        </div>

        <div class="container p-2">
            <pre class="rounded-3">
                <code class="language-python">
        import signal 
        import os 
        import time 
        
        def receive_signal(signum, stack):
            print("Received:", signum)
        
        def main():
        
            # Register signal handlers 
            signal.signal(signal.SIGUSR1, receive_signal)
            signal.signal(signal.SIGUSR2, receive_signal)
        
            print("My PID is:", os.getpid())
        
            while True:
                print("Waiting...")
                time.sleep(3)
        
        if __name__ == "__main__":
            main()
                </code>
            </pre>
        </div>

        <div class="container">
            <p class="m-3 text-secondary">
                The example script loops indefinitely, pausing for a few seconds each time. When a signal comes in, the <b>sleep()</b> call is interrupted and the signal handler <b>receive_signal</b> prints the signal number. After the signal handler returns, the loop continues.
            </p>
        </div>

        <div class="container p-2">
            <pre class="rounded-3">
                <code class="language-bash">
        $ python3 signal_signal.py 
        My PID is: 196544
        Waiting...
        Waiting...
        Waiting...
        Received: 10
        Waiting...
        Received: 12
        Waiting...
        Waiting...
        Traceback (most recent call last):
            File "signal_signal.py", line 21, in <module>
            main()
            File "signal_signal.py", line 18, in main
            time.sleep(3)
        KeyboardInterrupt                    
                </code>
            </pre>
        </div>

        <div class="container">
            <p class="m-3 text-secondary">
                Sending signals to the program.
                <br>
            </p>
        </div>

        <div class="container p-2">
            <pre class="rounded-3">
                <code class="language-bash">
        $ kill -USR1 $pid
        $ kill -USR2 $pid
        $ kill -INT $pid
                </code>
            </pre>
        </div>

        
        <!-- Retrieving Reigster Handlers -->
        <div id="SignalRetrievingReigsterHandlers" class="container">
            <h3>Receiving Signals</h3>
        </div>

        <div class="container">
            <p class="m-3 text-secondary">
                To see which signal handlers are registered for a signal, use <b>getsignal()</b>. Pass the signal number as an argument. The return value is the registered handler, or one of the special values <b>SIG_IGN</b> (if the signal is being ignored), <b>SIG_DFL</b> (if the default behaviour is being used), or <b>None</b> (if the existing signal hanler was registered from C, rather then Python).  
            </p>
        </div>

        <div class="container p-2">
            <pre class="rounded-3">
                <code class="language-python">
        import signal 

        def alarm_received(n, stack):
            return 

        def main():
            signal.signal(signal.SIGALRM, alarm_received)
            signals_to_names = {
                getattr(signal, n): n
                for n in dir(signal)
                if n.startswith("SIG") and "_" not in n
            }
        
            for s, name in sorted(signals_to_names.items()):
                handler = signal.getsignal(s)
                if handler is signal.SIG_DFL:
                    handler = "SIG_DFL"
                elif handler is signal.SIG_IGN:
                    handler = "SIG_IGN"
                print("{:&lt10} ({:2d}):".format(name, s), handler)
        
        if __name__ == "__main__":
            main()
                </code>
            </pre>
        </div>


        <!-- argument and thread name -->
        <div id="ThreadingThreadObjectArgumentsAndName" class="container">
            <h6 class="mt-3" id="">
                Passing Arguments and Thread Name
            </h6>
        </div>

        <div class="container">
            <p class="m-3 text-secondary">
                Passing arguments <i>(*args)</i> or keywords argument <i>(**kwargs)</i> is very easy. When we pass our worker function as target to Thread Object, we can also give our args (or kwargs) to the function with <i>args (or kwargs)</i>.
                <br>
            </p>
        </div>

        <div class="container p-2">
            <pre class="rounded-3">
                <code class="language-python">
        import threading
        from time import * 
        
        def worker(*args, **kwargs) -> None:
            # using thread name
            t_name: str = threading.current_thread().name
            
            print("{} started at {}".format(t_name, strftime("%Y-%m-%d:%H%M%S")))
            print("\n{} provide {} with value {}.\n".format(kwargs["name"], t_name, args[0]))
            sleep(1)
            print("{} completed at {}".format(t_name, strftime("%Y-%m-%d:%H%M%S")))
        
        def main() -> None:
            for i in range(5):
                # Creating thread
                t = threading.Thread(
                    target=worker,
                    args=(i,),
                    kwargs={"name": "paradox",},
                )
        
                #  naming our threads
                tname = "worker_" + str(i)     
                t.name = tname
        
                # starting threads
                t.start()
                
        if __name__ == "__main__":
            main()
                </code>
            </pre>
        </div>


        <!-- Lock Object -->
        <div id="#ThreadingLockObject" class="container">
            <h6 class="mt-3" id="">
                Lock Object
            </h6>
        </div>

        <div class="container">
            <p class="m-3 text-secondary">
                In the <i>Race Condition</i>, many threads simultaneously try to access value and modify, this can lead to error in application, because some might get modified value, while other get old value. This could result in severe damage. 
                <br>
                <br>
                To avoid error in <i>Race Condition</i> we use <i>Lock</i> Object, threads acquire lock one at a time, and modify value.
                <br>
            </p>
        </div>

        <div class="container p-2">
            <pre class="rounded-3">
                <code class="language-python">
        import threading
        from time import * 
        
        class lock_increment:
            lock = threading.Lock()
            number: int = 0
        
        def worker(*args, **kwargs) -> None:
            t_name: str = threading.current_thread().name
            
            while lock_increment.lock.locked():
                print("{:>10}: locked".format(t_name))
                sleep(1)
            else:
                lock_increment.lock.acquire()
                print("{:>10}: lock acquired".format(t_name))
                print("{:>10}: incrementing value".format(t_name))
                lock_increment.number += 1
                print("{:>10}: value is {}".format(t_name, lock_increment.number))
                lock_increment.lock.release()
                
            
        def main() -> None:
            for i in range(2):
                # Creating thread
                t = threading.Thread(
                    target=worker,
                    args=(i,),
                    kwargs={"name": "paradox",},
                )
        
                #  naming our threads
                tname = "worker_" + str(i)     
                t.name = tname
        
                # starting threads
                t.start()
                
        if __name__ == "__main__":
            main()
                </code>
            </pre>
        </div>




            
        <!-- See also  -->
        <div id="SeeAlso" class="container">
            <p class="m-3 text-info">
                ...
            </p>
        </div>

        <!-- code before here -->
    </div>
</div>