{% load static %}
<div id="Col2" class="col-lg-6 col-md-8">

    {% comment %} position bar {% endcomment %}
    <div class="container text-center text-bg-warning rounded mt-2">
        <ul class="bg-warning py-2">
            <li class="list-unstyled d-inline">
                <a href="{% url 'programming' %}" class="Link text-decoration-none text-dark">
                    programming
                </a>
            </li>
            <li class="list-unstyled text-dark d-inline">/</li>
            <li class="list-unstyled d-inline">
                <a href="{% url 'programming_py' %}" class="Link text-decoration-none text-dark">
                    python
                </a>
            </li>
            <li class="list-unstyled text-dark d-inline">/</li>
            <li class="list-unstyled d-inline">
                <a href="{% url 'programming_py_net_inter_com_signal' %}" class="Link text-decoration-none text-dark">
                    signal
                </a>
            </li>
        </ul>
    </div>

    <!-- <div class="container-fluid mt-2">
        <div class="container-fluid d-flex justify-content-center">
            <img class="h-100 w-100" src="{% static 'images/concurrency/PythonThreading' %}" alt="img not found">
        </div>
        <div class="container-fluid text-center">
            <small>Fig 1. Threading</small>
        </div>
    </div> -->

    <div class="container mt-4">
        <div class="container">
            <h3>signal: Asynchronous System Events</h3>

            <p class="m-3 text-secondary">
                Signals are on operating system feature that provide a means of notifying a program of en event, and
                having it handled asynchronously. They can be generated by the system itself, or sent from one process
                to another. Since signals interrupt the regular flow of the program, it is possible that some operations
                (especially I/O) may produce errors if a signal is recevied while they are ongoing.
            </p>

            <p class="m-3 text-info">
                Signals are identified by integers and are defined in the operating system C headers. Python exposes the
                signals appropriate for the platform as symbols in the <i>signal</i> module.
            </p>
        </div>

        <div class="container m-3" id="SignalReceivingSignals">
            <h3>Receiving Signals</h3>

            <p class="m-3 text-secondary">
                With other forms of event-based programming, signals are recevied by establishing a callback function,
                called a <i>signal handler</i>, that is invoked whe nthe signal occurs. The arguments to the signal
                handler are the signal number and the stack frame from the point in the program that was interrupted by
                the signal.
            </p>

            <pre class="">
                <code class="language-python">
        import signal 
        import os 
        import time 
        
        def receive_signal(signum, stack):
            print("Received:", signum)
        
        def main():
        
            # Register signal handlers 
            signal.signal(signal.SIGUSR1, receive_signal)
            signal.signal(signal.SIGUSR2, receive_signal)
        
            print("My PID is:", os.getpid())
        
            while True:
                print("Waiting...")
                time.sleep(3)
        
        if __name__ == "__main__":
            main()
                </code>
            </pre>

            <p class="m-3 text-secondary">
                The example script loops indefinitely, pausing for a few seconds each time. When a signal comes in, the
                <b>sleep()</b> call is interrupted and the signal handler <b>receive_signal</b> prints the signal
                number.
                After the signal handler returns, the loop continues.
            </p>

            <pre class="">
                <code class="language-bash">
        $ python3 signal_signal.py 
        My PID is: 196544
        Waiting...
        Waiting...
        Waiting...
        Received: 10
        Waiting...
        Received: 12
        Waiting...
        Waiting...
        Traceback (most recent call last):
            File "signal_signal.py", line 21, in <module>
            main()
            File "signal_signal.py", line 18, in main
            time.sleep(3)
        KeyboardInterrupt                    
                </code>
            </pre>

            <p class="m-3 text-secondary">
                Sending signals to the program.
                <br>
            </p>

            <pre class="">
                <code class="language-bash">
        $ kill -USR1 $pid
        $ kill -USR2 $pid
        $ kill -INT $pid
                </code>
            </pre>
        </div>


        <!-- Retrieving Reigster Handlers -->
        <div id="SignalRetrievingReigsterHandlers" class="container m-3">
            <h3>Retrieving Register Handlers</h3>

            <p class="m-3 text-secondary">
                To see which signal handlers are registered for a signal, use <b>getsignal()</b>. Pass the signal number
                as
                an argument. The return value is the registered handler, or one of the special values <b>SIG_IGN</b> (if
                the
                signal is being ignored), <b>SIG_DFL</b> (if the default behaviour is being used), or <b>None</b> (if
                the
                existing signal hanler was registered from C, rather then Python).
            </p>

            <pre class="">
                <code class="language-python">
        import signal 

        def alarm_received(n, stack):
            return 

        def main():
            signal.signal(signal.SIGALRM, alarm_received)
            signals_to_names = {
                getattr(signal, n): n
                for n in dir(signal)
                if n.startswith("SIG") and "_" not in n
            }
        
            for s, name in sorted(signals_to_names.items()):
                handler = signal.getsignal(s)
                if handler is signal.SIG_DFL:
                    handler = "SIG_DFL"
                elif handler is signal.SIG_IGN:
                    handler = "SIG_IGN"
                print("{:&lt10} ({:2d}):".format(name, s), handler)
        
        if __name__ == "__main__":
            main()
                </code>
            </pre>
        </div>

        <div class="container m-3" id="SignalAlarm">
            <h3>Alarms</h3>
            <p class="m-3 text-secondary">
                Alarms are a special sort of signal, which are generated when the program asks the OS to notify it after
                some period of time has elapsed.
            </p>
            <pre>
                <code class="language-python">
        import signal
        import time 
        
        def receive_alarm(signum, stack):
            print("Alarm: ", time.ctime())
        
        # Call recevie_alarm in 2 seconds.
        signal.signal(signal.SIGALRM, receive_alarm)
        signal.alarm(2)
        
        print("Before:", time.ctime())
        time.sleep(4)
        print("After:", time.ctime())
                </code>
            </pre>

            <p class="m-3 text-secondary">
                Output:
            </p>
            <pre>
                <code class="language-bash">
        Before: Sun Oct  2 14:09:03 2022
        Alarm:  Sun Oct  2 14:09:05 2022
        After: Sun Oct  2 14:09:07 2022

                </code>
            </pre>

            <p class="m-3 text-secondary">
                Call to <i>sleep()</i> is interrupted, but then continues after the signal is processed. The message printed after <i>sleep()</i> returns show that the program was paused for atleast as long as the sleep duration.
            </p>
        </div>


        <div class="m-3 container" id="SignalIgnoringSignals">
            <h3>Ignoring Signals</h3>
            <p class="m-3 text-secondary">
                To ignore a signal, register <i>SIG_IGN</i> as the handler. This script replaces the defualt handler for <i>SIGINT</i> with <i>SIG_IGN</i>, and registers a handler for <i>SIGUSR1</i>. It then uses <i>signal.pause()</i> to wait for a singal to be received.
            </p>
            <pre>
                <code class="language-python">
        import signal 
        import os 
        import time 
        
        def do_exit(sig, stack):
            raise SystemExit("Exiting")
        
        signal.signal(signal.SIGINT, signal.SIG_IGN)
        signal.signal(signal.SIGUSR1, do_exit)
        
        print("My PID:", os.getpid())
        
        signal.pause()
                </code>
            </pre>

            <p class="m-3 text-secondary">
                Normally <i>SIGINT</i> (the signal sent by the shell to a program when the user presses a Ctrl+C) raise a <i>KeyboardInterrupt</i>. This example ignores <i>SIGINT</i> and raises <i>SystemExit</i> when it received <i>SIGUSR1</i>. Each ^C is the outpt represents an attempt to use <i>Ctrl+C</i> to kill the script from the terminal. Using <i>kill -USR1 72598</i> from another terminal eventually causes the script to exit.
            </p>

            <pre>
                <code class="language-bash">
        $ python3 signal_ignore.py
        
        My PID: 72598
        ^C^C^C^CExiting
                </code>
            </pre>
        </div>


        <div class="container m-3" id="SignalSignalsThreads">
            <h3>Signals and Threads</h3>
            <p class="m-3 text-secondary">
              Mixing signals and threads rarely works well because only the main thread of a process will received signals.  
            </p>
            <pre>
                <code class="language-python">
        import signal 
        import threading 
        import os 
        import time 
        
        def signal_handler(num, stack):
            print(
                "Received signal {} in {}".format(
                    num,
                    threading.current_thread().name
                )
            )
        
        signal.signal(signal.SIGUSR1, signal_handler)
        
        def wait_for_signal():
            print(
                "Waiting for signal in",
                threading.current_thread().name,
            )
            signal.pause()
            print("Don waiting")
        
        receiver = threading.Thread(
            target=wait_for_signal,
            name="receiver",
        )
        receiver.start()
        time.sleep(0.1)
        
        
        def send_signal():
            print("Sending signal in", threading.current_thread().name)
            os.kill(os.getpid(), signal.SIGUSR1)
        
        sender = threading.Thread(target=send_signal, name="sender")
        sender.start()
        sender.join()
        
        print('waiting for', receiver.name)
        signal.alarm(2)
        receiver.join()
                </code>
            </pre>

            <p class="m-3 text-secondary">
                The signal handlers were all registered in the main thread because this is a requirement of the <i>signal</i> module implementation for Python, regardless of underlying platform support for mixing threads and signals. Although the receiver thread calls <i>signal.pause()</i>, it does not receive the signal. The <i>signal.alarm(2)</i> call near the end of the example prevents an infinite block, since the receiver thread will never exit.

                <br>
                <br>
            </p>

            <pre>
                <code class="language-bash">
        $ python3 signals_threads.py 

        Waiting for signal in receiver
        Sending signal in sender
        Received signal 10 in MainThread
        waiting for receiver
        Alarm clock

                </code>
            </pre>


            <p class="m-3 text-secondary">
                Although alarms can be set in any thread, they are always recevied by the main thread.
            </p>

            <pre>
                <code class="language-python">
        import signal 
        import time 
        import threading 
        
        def signal_handler(num, stack):
            print(
                time.ctime(), "Alarm in", 
                threading.current_thread().name,
            )
        signal.signal(
            signal.SIGALRM, 
            signal_handler,
        )
        
        def use_alarm():
            t_name = threading.current_thread().name 
            print(
                time.ctime(),
                "Setting alarm in",
                t_name,
            )
            signal.alarm(1)
            print(
                time.ctime(),
                "Sleeping in",
                t_name,
            )
            time.sleep(3)
            print(
                time.ctime(),
                "Done with sleep in", 
                t_name,
            )
        
        # Start a thread that will not receive the signal.
        alarm_thread = threading.Thread(
            target=use_alarm,
            name="alarm_thread",
        )
        
        alarm_thread.start()
        time.sleep(0.1)
        
        # Wait for the thread to see the signal (not going to happen!).
        print(time.ctime(), "Waiting for", alarm_thread.name)
        alarm_thread.join()
        
        print(time.ctime(), "Exiting normally")
                </code>
            </pre>

            <p class="m-3 text-secondary">
                In this example, the alarm does not abort the <i>sleep()</i> call in <i>use_alarm()</i>.
            </p>

            <pre>
                <code class="language-bash">
        $ python3 signals_threads_alarm.py 

        Sun Oct  2 17:45:44 2022 Setting alarm in alarm_thread
        Sun Oct  2 17:45:44 2022 Sleeping in alarm_thread
        Sun Oct  2 17:45:44 2022 Waiting for alarm_thread
        Sun Oct  2 17:45:45 2022 Alarm in MainThread
        Sun Oct  2 17:45:47 2022 Done with sleep in alarm_thread
        Sun Oct  2 17:45:47 2022 Exiting normally
                    
                </code>
            </pre>
        </div>


        
        <!-- code before here -->
    </div>
</div>